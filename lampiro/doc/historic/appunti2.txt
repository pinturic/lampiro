DATA FORMS:
- potere aggiungere l'help del controllo selezionato [LOW P., uso di Field.desc]
- il meccanismo con cui le Forms comporta l'uso di listener, necessario implementarne
  un paio per capire se ci sono magagne nascoste.
- aggiungere la gestione del type=result sulle DataForm.



Fabio Forno <fabio.forno@gmail.com>   	  1 marzo 2006 0.17
A: luca.tagliaferri@gmail.com, alex.malgaroli@gmail.com, Elias Carotti <elias.carotti@polito.it>
Note sparse

- Copiare UI da Bombus -> presto disponibile su svn

Creazione account
1) client installato di nuovo?
  -> all'avvio schermata creazione account  [OK]
  -> solo username, password (la si ricorda), email (opzionale) [OK]
1.1 verifica password [banale]
1.2 sha1 password [OK]

2) Gestione roster
  -> lista ordinata x freq di contatti - in cima quelli online
  -> ricerca stile rubrica
  -> gruppi [?? se uso la frequenza perchè?] [hyp: poi, comportamento impostabile da config]
  -> icona status [OK]
  Azioni:
  -> crud [OK]
  -> inizia conversazione [OK]

3) 1 form per ogni conversazione aperta [OK]

4) 1 schermata per settare il proprio status, con messaggi personalizzati
[OK]

5) gestione vcard
 [ --> standard? ]
 campi necessari:
 - VERSION, FN, N
 - NICKNAME -> ?
 - PHOTO (TYPE, BINVAL)
 - BDAY
 - ADR
 - TEL
 - EMAIL
 - JABBERID
 - GEO --> ? interessante, ma dovrebbe aggiornarlo lo YUP quando va online!
 Pensiero: inutile forse filtrare i dati: se chiedo la foto ho già con ogni 
 probabilità l'85% dei byte della vCard...
 Pensieri: il roster posso memorizzarlo come una serie di vCard? Credo di sì, in 
 quanto può essere agganciato alla vCard tramite JabberID cui aggiungerei campi
 "jabber-specific":
 - Y_SUBSCRIPTION
 - Y_GROUPS
 - Y_NICNKAME
 - Y_STATUS
 Memorizzerei nello storage, in un suo RMS il roster come una serie di vCard,
 in questo modo:
 vCardRMS: <vCard length> [<vCards>]
 vCard length: short (2 byte)   {number of vCards stored}
 vCards: <vCard> [<vCard> ...]
 vCard: <vCard fields> <vField>
 vCard fields: short (2 byte)   {number of fields composing this vCard}
 vField: <fieldId> <fieldData>
 fieldId: short (2 byte)      {ID of vCard fields}
 fieldData: UTF string   {if fieldData is "<" then following field are nested 
 	inside this field. Nesting ends with a fieldId = 0 with value = ">"
 
 Field Map - vedere al fondo
 

6) MUC
  -> scoprire chat attive, iscriversi
  -> creare una chat
  -> form chat -> invio messaggi, invito contatti

7) service discovery
  -> schermata
  -> form x riempire campi inviati da servizio (data form)

8) File Transfer -> gestito con obex da cosillo/server


Comunicazione trasporto <-> client

Una classe che ingloba i due connettori gprs/bt
  - connettore bt sempre disponibile con client aperto
  - connecttore gprs a richiesta dal client. due modalita':
    1) invia immediamente i messaggi se non c'è bt dispobile
    2) wait x secondi
  - una send con flag urgent
  - addPacketListener(PaketFilter, listener)
  - addOnetimePacketListener(PaketFilter, listener)

-----------------------

11/4/2006

Minimizzazione delle informazioni spedite/ricevute su GPRS
- Roster (vCard inclusa) da mantenere su RecordStore. Il Roster ha un hash 
	(calcolato dal server) da memorizzare. Ogni volta parto da quell'hash e se
	il server ritiene opportuno mi da il delta
- Presenza da mantenere su RecordStore.

vCard
- JEP 54  (vcard-temp)
- JEP 153 (vcard-avatars)
- JEP 164 (specifiche per indicare parti vcard di interesse)
   vedere orkut per info da prendere

Immagini (MMAPI)/OBEX per File Transfer


FIELD MAP PER VCARD
01  VERSION
02  FN
03  N
04   FAMILY
05   GIVEN
06   MIDDLE
07   PREFIX
08   SUFFIX
09  NICKNAME
10  PHOTO 
11   TYPE
12   BINVAL
13   EXTVAL
14  BDAY 
15  ADR 
16   HOME
17   WORK
18   POSTAL
19   PARCEL
20   DOM
21   INTL
22   PREF
23   POBOX
24   EXTADD
25   STREET
26   LOCALITY
27   REGION
28   PCODE
29   CTRY
30  LABEL 
     HOME
     WORK 
     POSTAL
     PARCEL
     DOM
     INTL
     PREF
38   LINE
39  TEL 
     HOME
     WORK
42   VOICE
43   FAX
44   PAGER
45   MSG
46   CELL
47   VIDEO
48   BBS
49   MODEM
50   ISDN
51   PCS
     PREF
53   NUMBER
54  EMAIL
     HOME
     WORK
57   INTERNET
     PREF
59   X400
60   USERID
61  JABBERID
62  MAILER 
63  TZ 
64  GEO 
65   LAT
66   LON
67  TITLE 
68  ROLE  
69  LOGO 
     TYPE
     BINVAL
     EXTVAL
73  AGENT 
74  ORG 
75   ORGNAME 
76   ORGUNIT
77  CATEGORIES 
78   KEYWORD
79  NOTE 
80  PRODID 
81  REV 
82  SORT-STRING 
83  SOUND 
84   PHONETIC
     BINVAL
     EXTVAL
87  UID 
88  URL 
89  CLASS 
90   PUBLIC
91   PRIVATE
92   CONFIDENTIAL
93  KEY
     TYPE
95   CRED 
96  DESC


-------------------------------

Allora, a basso livello noi stiamo ritoccando parecchio (è un casino gestire in 
modo coerente le disocnessioni), però il tuo client dall'alto vede solo la classe 
YupConnector che ha un'interfaccia stabile.
Nel package test c'è un esempio minimale di come costruire pacchetti, inviarli 
e riceverli: solo send per l'invio e addPacketListner per la ricezione. la send 
è asincorna, quindi non devi preoccuparti di eventuali blocchi, invece quando 
packetReceived viene chiamata sei sincrono, quindi è meglio che ritorni il piu' 
in fretta possible (se l'operazione è in qualche modo bloccante serve un thread)

-------------------------------

file transfer:
* ad-hoc commands (iniziati dal cosillo)
* spedire file: elenco di cosilli, recuperatro tramite presence speciale che ha 
  figlio x con un namespace.
  Presence ricevuta tramite PacketListener apposito (messaggio fittizio creato
  dal connection listener)
* per l'elenco di jabberID, vedere XEP 68. Stesso meccanismo di FORM_TYPE, 
  usando un hidden con un nome particolare che indica autocomplete.
  Nel valore, fare riferimento alla variabile e indicare la metodologia di
  autocompletamento. Possono esssere usati più valori nei campi hidden: un 
  unico campo con più valori.
  
DataForm:
- predisporre la possibilità di recuperare la form per completarla più tardi.
- il reply della form deve costruire il messaggio necessario sulla base del tipo
  di messaggio ricevuto (message o iq)

-------------------------------------

Finto Frontend:
- login
- google maps
- quattro o cinque cosilli sparsi (locali)
- selezione di un cosillo
- upload di un file sul cosillo (advertisement / campagne)
- pagamento: numero di volte, 
- deposito del file sul server da qualche parte

--> Fabio provvederà a spedire il file via BT sulle apps

----------------------------------------


ave
(x il mollea) dovresti vedere alcune cose sul client quando hai tempo:

- come implementare gli ad hoc commands (c'è uan jep) sul client:
nell'ottica mw sono essenziali (gran parte del lavoro è già fatto,
visto che poi all'interno usano data form)
- vedere come far apparire l'applicazione e fare casino quando si
riceve un comando
- stuadiare la parte di basso livello fatta da me e pinturicchio per
aggiungere anche il client che si connette: questo è essenziale per
ottimizzare al comunicazione;
Mo spiego:
- il cosillo cerca client e fa sdp a ripetizione
- quando trova un servizio con YupService se lo segna e lo rimuove
dopo un po di volte che non lo trova più in una inquiry
- la prima volta che lo vede si connette e scambia dati, sconnettendosi subito
- dopo si connette solo più se gli arrivano dati dal server per quel client
- il cellulo non fa mai inquiry, ma si segna gli indirizzi dei cosilli
che si connettono (facendo una sdp per segnarsi al porta)
- il cellulo prova a connetersi agli ultimi 2/3 cosilli quando ha
qualcosa da trasmettere (che sono ovviamente anche in ascolto): dopo
un po' di volte che non ci riesce più si disconnette

in questo modo il numero di connessioni che faccio è veramente minimo,
e tengo libero il device blututu per il file trasfer

-----------------------------
(ex appunti 2)

INTERFACCIA DI BOMBUS
Roster permette di:
- alert profile (tipologia di avviso alla ricezione di un messaggio) [POI]
- actions (= modifica contatto)
	vCard
	Subscription
	Delete
- conference [POI]
- archive [POI]
- tools
	- service discovery [POI]
	- privacy list [POI]
	- vcard [POI]
- options ()


/****** VECCHIA IMPLEMENTAZIONE  ROSTER - DIVISIONE PER GRUPPI *******/
package it.yup.screens;

import java.io.IOException;
import java.util.Enumeration;
import java.util.Vector;

import javax.microedition.lcdui.Canvas;
import javax.microedition.lcdui.Command;
import javax.microedition.lcdui.CommandListener;
import javax.microedition.lcdui.Display;
import javax.microedition.lcdui.Displayable;
import javax.microedition.lcdui.Font;
import javax.microedition.lcdui.Graphics;
import javax.microedition.lcdui.Image;

import it.yup.YUPMidlet;
import it.yup.xmpp.Contact;
import it.yup.xmpp.Group;
import it.yup.xmpp.XMPPClient;

public class RosterScreen extends Canvas implements CommandListener {

    private Command cmd_exit  = new Command("Esci", Command.SCREEN, 1);
    private Command cmd_send  = new Command("Invia Messaggio", Command.ITEM, 1);
    private Command cmd_chat  = new Command("Chat", Command.ITEM, 1);
    private Command cmd_info  = new Command("Modifica Contatto", Command.ITEM, 1);
    private Command cmd_addc  = new Command("Aggiungi Contatto", Command.ITEM, 1);
    private Command cmd_delc  = new Command("Rimuovi Contatto", Command.ITEM, 1);
    private Command cmd_state = new Command("Stato", Command.ITEM, 1);
    
    private Image img_msg;
    
    /** la dimensione della finestra */
    public static int wsize;
    /** il font usato per scrivere la conversazione */
    public static Font f_u;
    
    /** la linea di partenza da cui partire a disegnare il roster */
    private int start_line;
    /** la linea evidenziata */
    private int selected_line;
    /** l'ultima linea mostrata */
    private int last_line;
    
    /** comandi di scroll abilitati */
    private byte scroll_enable;
    
    public static final byte SCROLL_DOWN = 1;
    public static final byte SCROLL_UP   = 2;

    /** singleton */
    private static RosterScreen _instance;
    
    private RosterScreen() {
        addCommand(cmd_addc);
        addCommand(cmd_exit);
        addCommand(cmd_state);
        setCommandListener(this);
        f_u = Font.getFont(Font.FACE_PROPORTIONAL, Font.STYLE_PLAIN, Font.SIZE_SMALL);
        start_line = 0;
        selected_line = -1;
        scroll_enable = 0;
        
        try {
			img_msg = Image.createImage("/icons/message.png");
		} catch (IOException e) {
			img_msg = Image.createImage(16, 16);
		}
        
    }
    
    public static RosterScreen getInstance() {
    	if(_instance == null) {
    		_instance = new RosterScreen();
    	}
    	return _instance;
    }

    /**
     * Ridipinge il componente.
     * @param g
     *      il contesto grafico usato.
     */
    protected void paint(Graphics g) {
    	XMPPClient xmpp = XMPPClient.getInstance();
        int w = g.getClipWidth();
        int h = g.getClipHeight();
        wsize = w;
	    setTitle("Roster (" + xmpp.contacts.size() + " contacts)");

        Font f_g = Font.getFont(Font.FACE_PROPORTIONAL, Font.STYLE_BOLD, Font.SIZE_MEDIUM);
        g.setColor(0x00FFFFFF);
        g.fillRect (0, 0, w, h);
        g.setColor(0x00000000);
        
        int hpos = 3;
        
        int hdelta = 0;
        if(img_msg.getHeight() > f_u.getHeight() + 2) {
        	hdelta = img_msg.getHeight();
        } else {
        	hdelta = f_u.getHeight() + 2;
        }
        
        Enumeration e = xmpp.groups.elements();
        boolean more = false;
        int cur_line = 0;
        while( e.hasMoreElements() ) {
            Group grp = (Group)e.nextElement();
            if(grp.type == Contact.TRANSPORT) {
                /* i trasporti alla fine */
                continue;
            }
            String ghead = "[" + (grp.name == null ? "(generico)" : grp.name)+ "]";
            g.setFont(f_g);
            if( (hpos + f_g.getHeight() + 3) > h) {
                more = true;
                break;
            }
            if(cur_line >= start_line) {
                g.drawString(ghead, 3, hpos, 0);
                hpos += f_g.getHeight() + 2;
                g.drawLine(3, hpos, w - 3, hpos);
                hpos++;
            }
            
            g.setFont(f_u);
            
            Vector v = grp.contacts;
            for(int i = 0; i < v.size(); i++) {
                if( (hpos + f_g.getHeight() + 2) > h) {
                    more = true;
                    break;
                }
                if(cur_line < start_line) {
                    cur_line++;
                    continue;
                }
                Contact u = (Contact)v.elementAt(i);
                String uname = u.getName();
                Image pimg = u.status.stat.getImage(); 
                if(u.unread_msg) {
                    pimg = img_msg;
                }
                g.drawImage(pimg, 0, hpos, Graphics.TOP | Graphics.LEFT);
                g.drawString(uname, 19, hpos + 1, Graphics.TOP | Graphics.LEFT);
                if(selected_line == cur_line) {
                	int oc = g.getColor();
                	g.setColor(0x000000C0);
                    g.drawRect(17, hpos, g.getClipWidth() - 20, hdelta);
                	g.setColor(oc);
                }
                hpos += hdelta;
                cur_line++;
            }
            if(more) {
                break;
            }
            hpos += 2;
        }
        last_line = cur_line;
        
        /* ci sono pezzi sopra */
        scroll_enable = 0;
        if(start_line > 0) {
            g.setColor(0x00FFFFFF);
            g.drawRect(w-13, 2, 13, 13);
            g.setColor(0x40C040);
            g.fillTriangle(w-13, 13, w-2, 13, w-8, 4);
            scroll_enable |= SCROLL_UP;
        }
        if(more) {
            g.setColor(0x00FFFFFF);
            g.drawRect(w-13, h-15, 13, 13);
            g.setColor(0x40C040);
            g.fillTriangle(w-13, h-14, w-2, h-14, w-8, h-4);

            /* abilito lo scroll con 2 & 8 */ 
            scroll_enable |= SCROLL_DOWN;
        }

        /* aggiungo o rimuovo i comandi solo se ho un utente selezionato */
        if(getSelectedContact() == null) {
            removeCommand(cmd_delc);
            removeCommand(cmd_send);
            removeCommand(cmd_info);
            removeCommand(cmd_chat);
        } else {
            addCommand(cmd_delc);
            addCommand(cmd_send);
            addCommand(cmd_info);
            addCommand(cmd_chat);
        }
        
    }
    
    /**
     * Risponde ad un evento di pressione tasti.
     * @param kc
     *      il codice del tasto premuto.
     */
    protected void keyPressed(int kc) {
        boolean game = false;

        switch(kc) {
            case Canvas.KEY_NUM2: {
                if( (scroll_enable & SCROLL_UP) != 0 && start_line > 0) {
                    start_line--;
                }
                // spostare indietro la selected line se supera l'ultima linea
                break;
            }
            case Canvas.KEY_NUM5: {
                selected_line = -1;
                removeCommand(cmd_info);
                removeCommand(cmd_send);
                removeCommand(cmd_chat);
                break;
            }
            case Canvas.KEY_NUM8: {
                if( (scroll_enable & SCROLL_DOWN) != 0) {
                    start_line ++;
                    if(selected_line != -1 && selected_line < start_line) {
                       selected_line = start_line;
                    }
                }
                break;
            }
            default: {
                game = true;
                break;
            }
        }

        if(!game) {
            repaint();
            return;
        }
        
        int ga = getGameAction(kc);
        XMPPClient xmpp = XMPPClient.getInstance();
        switch(ga) {
            case Canvas.DOWN: {
                if(selected_line < xmpp.contacts.size() - 1) {
                    selected_line++;
                }
                if(selected_line < start_line) {
                    selected_line = start_line;
                }
                if(selected_line >= last_line) {
                    start_line++;
                }
                repaint();
                return;
            }
            case Canvas.UP: {
                if(selected_line == -1) {
                    selected_line = last_line;
                }
                if(selected_line > 0) {
                    selected_line--;
                }
                if(selected_line > last_line) {
                    selected_line = last_line;
                }
                if(selected_line < start_line) {
                    start_line = selected_line;
                }
                repaint();
                return;
            }
            default: {
                break;
            }
        }
        
        repaint();
    }

    /**
     * Risponde ad un comando.
     * @param c
     *      il comando invocato
     * @param d
     *      l'oggetto su cui è stato invocato il comando
     */
    public void commandAction(Command c, Displayable d) {
    	YUPMidlet yup = YUPMidlet.yup;
    	Display disp = YUPMidlet.disp;
        if(c == cmd_exit) {
            yup.exit();
        } else if(c == cmd_delc) {
        	DeleteContactAlert a = new DeleteContactAlert(getSelectedContact());
        	disp.setCurrent(a);
        } else if(c == cmd_addc) {
            ContactScreen acs = new ContactScreen(null);
            disp.setCurrent(acs);
        } else if(c == cmd_info) {
            Contact user = getSelectedContact();
            ContactScreen acs = new ContactScreen(user);
            disp.setCurrent(acs);
        } else if(c == cmd_send) {
            Contact user = getSelectedContact();
            ComposerScreen ms = new ComposerScreen(this, user);
            disp.setCurrent(ms);            
        } else if(c == cmd_chat) {
            Contact user = getSelectedContact();
            ChatScreen ms = new ChatScreen(user);
            disp.setCurrent(ms);            
        } else if(c == cmd_state) {
        	StatusScreen ssc = StatusScreen.getInstance();
        	ssc.sync();
        	disp.setCurrent(ssc);
        }
    }

    private Contact getSelectedContact() {
    	XMPPClient xmpp = XMPPClient.getInstance();
        int sidx = selected_line;
        if(sidx < 0) {
            return null;
        }
        Enumeration e = xmpp.groups.elements();
        while( e.hasMoreElements() ) {
            Group grp = (Group)e.nextElement();
            Vector v = grp.contacts;
            if(sidx >= v.size()) {
                sidx -= v.size();
                continue;
            }
            Contact u = (Contact)v.elementAt(sidx);
            return u;
        }
        return null;
    }

}


